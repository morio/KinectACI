#!/usr/bin/env python# -*- coding: utf-8 -*-#   Copyright 2011 Peter Morton & Matthew Yeung##   Licensed under the Apache License, Version 2.0 (the "License");#   you may not use this file except in compliance with the License.#   You may obtain a copy of the License at##	   http://www.apache.org/licenses/LICENSE-2.0##   Unless required by applicable law or agreed to in writing, software#   distributed under the License is distributed on an "AS IS" BASIS,#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.#   See the License for the specific language governing permissions and#   limitations under the License.from PyQt4 import QtCore, QtGuifrom PyQt4.QtCore import pyqtSignal, QEvent, QObjectimport PyQGLViewerimport OpenGL.GL as oglimport numpy as npimport freenectfrom espeak import espeakimport pygame#from Onboard.Keyboard import Keyboardimport typewriterfrom keyboard import Keyboard# Play with these constants to change the system responseSAMPLE_STRIDE = 2		  # Divide depth map resolution by this amountKB_WIDTH_FAC = 1		 # Width of keyboard = Length * KB_WIDTH_FACKB_HEIGHT_FAC = 1	   # Height of keyboard = Length * KB_HEIGHT_FACKB_GAP_FAC = 0.01		  # Gap between keys = KB Length * KB_GAP_FACKB_NUM_KEYS = 4		   # Only dealing with white keys for nowKB_START_KEY = 0		   # 0 = C2, 1 = D2, etc... (whites only)AUDIO_PATH = "../audio"# Precompute U, V coordinates (since they never change)U, V = np.meshgrid(np.arange(0,640, SAMPLE_STRIDE), 				   np.arange(0,480, SAMPLE_STRIDE))def depth_to_xyz(u, v, stride, depth):	""" Convert depth map to cartesian coordinates. 		Parameters as originally determined by Zephod (? I think). Or found on	the OpenKinect.org mailing list		"""		depth_flipped = depth[::-stride, ::stride]	valid = depth_flipped != 2047	# Non-return = 2047		us = u[valid].flatten()	vs = v[valid].flatten()	ds = depth_flipped[valid]	KinectMinDistance = -10	KinectDepthScaleFactor = .0021		zz = 100.0 / (-0.00307 * ds + 3.33)	xx = (us - 320) * (zz + KinectMinDistance) * KinectDepthScaleFactor	yy = (vs - 240) * (zz + KinectMinDistance) * KinectDepthScaleFactor	zz = -(zz - 200)	# Move sensor from origin (easier for displaying)		points = np.vstack((xx,yy,zz)).astype(float)	return points					 class Viewer(PyQGLViewer.QGLViewer):	""" Subclass PyQGLViewer to provide additional functionality. """		def __init__(self, connector):		PyQGLViewer.QGLViewer.__init__(self)				self.points = np.zeros((3,1))		self.connector = connector		self.keyboards = [Keyboard(Keyboard.TYPE_FORWARD, 4, 1, 1, 0.001, 0,"keyboard1.npy" , connector), \						Keyboard(Keyboard.TYPE_REVERSE, 4, 1, 1, 0.001, -8, "keyboard2.npy", connector), \						Keyboard(Keyboard.TYPE_SELECT, 1, 2, 2, 0.01, -16, "keyboard3.npy", connector)]		self.num_keyboard = 3		self.keyboard = self.keyboards[0]	def init(self):		""" For initialisation once OpenGL context is created. """		self.setAnimationPeriod(33)				ogl.glDisable(ogl.GL_LIGHTING)		ogl.glEnableClientState(ogl.GL_VERTEX_ARRAY)		ogl.glEnable(ogl.GL_BLEND)		ogl.glBlendFunc(ogl.GL_SRC_ALPHA, ogl.GL_ONE_MINUS_SRC_ALPHA)		ogl.glEnable(ogl.GL_CULL_FACE)		ogl.glPointSize(2.0)		self.setStateFileName('keyboard_anywhere.xml')		if not self.restoreStateFromFile():			self.camera().setSceneRadius(500)				# Make key commands appear in the help		self.kbt = ['lower left', 'lower right', 'upper left']		self.setKeyDescription(QtCore.Qt.Key_1, 				'set the {0} point of the keyboard'.format(self.kbt[0]))				self.setKeyDescription(QtCore.Qt.Key_2, 				'set the {0} point of the keyboard'.format(self.kbt[1]))				self.setKeyDescription(QtCore.Qt.Key_3, 				'set the {0} point of the keyboard'.format(self.kbt[2]))		self.setKeyDescription(QtCore.Qt.Key_Z,				'shift the keyboard slightly in the local +Z direction')		self.setKeyDescription(QtCore.Qt.ShiftModifier + QtCore.Qt.Key_Z,				'shift the keyboard slightly in the local -Z direction')		self.setKeyDescription(QtCore.Qt.Key_Plus, 				'rotate the keyboard slightly about the local +Y axis')		self.setKeyDescription(QtCore.Qt.Key_Minus, 				'rotate the keyboard slightly about the local -Y axis')				self.tilt = 0; 		self.kb_corners = np.zeros((3,3))		self.kb_corner_index = 0							def animate(self):		""" Get the latest data from the kinect, and update the state. """					depth, timestamp = freenect.sync_get_depth()		xyz = depth_to_xyz(U, V, SAMPLE_STRIDE, np.array(depth))		self.points = xyz		for board in self.keyboards :			board.update(self.points)		def draw(self):		""" Draw the point cloud and keyboard. """ 		ogl.glColor4f(0.6,0.6,0.6,1)		ogl.glVertexPointer(3, ogl.GL_FLOAT, 0, self.points.T)		ogl.glDrawArrays(ogl.GL_POINTS, 0, self.points.shape[1])		for board in self.keyboards :			board.draw()	def keyPressEvent(self, event):		""" Handle keyboard events. """				if event.key() == QtCore.Qt.Key_F1:			self.kb_corner_index = 0			self.displayMessage('shift + click to set {0} corner'.format(self.kbt[0]))		elif event.key() == QtCore.Qt.Key_F2:			self.kb_corner_index = 1			self.displayMessage('shift + click to set {0} corner'.format(self.kbt[1]))		elif event.key() == QtCore.Qt.Key_F3:			self.kb_corner_index = 2			self.displayMessage('shift + click to set {0} corner'.format(self.kbt[2]))		elif event.key() == QtCore.Qt.Key_Z:			# Shift the keyboard in Z				if event.modifiers() and QtCore.Qt.ShiftModifier:				self.keyboard.nudge_z(-1)			else:				self.keyboard.nudge_z(1)					   			self.updateGL()		elif event.key() == QtCore.Qt.Key_R:			self.keyboard.nudge_pitch(1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_F:			self.keyboard.nudge_pitch(-1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_E:			self.keyboard.nudge_yaw(1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_Q:			self.keyboard.nudge_yaw(-1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_I:			self.keyboard.scale_x(1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_J:			self.keyboard.scale_x(-1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_O:			self.keyboard.scale_y(1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_K:			self.keyboard.scale_y(-1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_P :			self.keyboard.scale_z(1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_L :			self.keyboard.scale_z(-1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_A:			self.keyboard.nudge_x(-1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_D:			self.keyboard.nudge_x(1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_W:			self.keyboard.nudge_y(1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_S:			self.keyboard.nudge_y(-1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_C:			# Rotate the keyboard			self.keyboard.nudge_roll(1)  			self.updateGL()		elif event.key() == QtCore.Qt.Key_X:	  			# Rotate the keyboard			self.keyboard.nudge_roll(-1)			self.updateGL()		elif event.key() == QtCore.Qt.Key_Plus:			self.keyboard.scale += 1			self.displayMessage("Transform scale is set to {0}".format(self.keyboard.scale))		elif event.key() == QtCore.Qt.Key_Minus:			if self.keyboard.scale > 1.0 :				self.keyboard.scale -= 1				self.displayMessage("Transform scale is set to {0}".format(self.keyboard.scale))		elif event.key() == QtCore.Qt.Key_1:			self.keyboard = self.keyboards[0]			self.displayMessage("Seleccted first keyboard")		elif event.key() == QtCore.Qt.Key_2:			self.keyboard = self.keyboards[1]			self.displayMessage("Selected second keyboard")		elif event.key() == QtCore.Qt.Key_3:			self.keyboard = self.keyboards[2]			self.displayMessage("Selected third keyboard")		else:			PyQGLViewer.QGLViewer.keyPressEvent(self, event)		def compute_keyboard_transformation(self):		""" Compute the keyboard transform from the corner points. """				def unitize(v):			return v / np.linalg.norm(v)					translation = self.kb_corners[:, 0]			x_axis = np.subtract(self.kb_corners[:, 1], self.kb_corners[:, 0])		scale = np.linalg.norm(x_axis)	# Length of keyboard	   		planar_vec = np.subtract(self.kb_corners[:, 2], self.kb_corners[:, 0])		z_axis = unitize(np.cross(x_axis, planar_vec)) * scale		y_axis = -unitize(np.cross(x_axis, z_axis)) * scale					rot_scale = np.vstack((x_axis, y_axis, z_axis)).T				# H stores the computed transform		H = np.eye(4)		H[0:3, 0:3] = rot_scale		H[0:3, 3] = translation				self.keyboard.set_transform(H)		def select(self, event):		""" Handler for mouse select event. """		pos = event.pos()				pt, ok = self.camera().pointUnderPixel(pos)		if(ok):			cnr_txt = self.kbt[self.kb_corner_index]			self.displayMessage('{0} corner is set'.format(cnr_txt))			self.kb_corners[:, self.kb_corner_index] = list(pt)						self.compute_keyboard_transformation()	def helpString(self):		""" Text shown in help window. """		output = "<h2>keyboard-anywhere</h2>"		output += "<p>Press ENTER to start/stop live display of Kinect Data.</p>"		output += "<p>Press F1, F2 or F3 to set the keyboard anchor points.</p>"		output += "<p>Press the virtual keys to play!</p>"		return outputclass Connector(QtCore.QObject):	sendkey = pyqtSignal(int, int, name="sendkey")	def __init__(self, ui, typewriter):		QtCore.QObject.__init__(self)		self.ui = ui		self.typewriter = typewriter		self.append = Append(ui)	def connect(self):		self.ui.pushButton_A.clicked.connect(self.append.addA)		self.ui.pushButton_B.clicked.connect(self.append.addB)		self.ui.pushButton_C.clicked.connect(self.append.addC)		self.ui.pushButton_D.clicked.connect(self.append.addD)		self.ui.pushButton_E.clicked.connect(self.append.addE)		self.ui.pushButton_F.clicked.connect(self.append.addF)		self.ui.pushButton_G.clicked.connect(self.append.addG)		self.ui.pushButton_H.clicked.connect(self.append.addH)		self.ui.pushButton_I.clicked.connect(self.append.addI)		self.ui.pushButton_J.clicked.connect(self.append.addJ)		self.ui.pushButton_K.clicked.connect(self.append.addK)		self.ui.pushButton_L.clicked.connect(self.append.addL)		self.ui.pushButton_M.clicked.connect(self.append.addM)		self.ui.pushButton_N.clicked.connect(self.append.addN)		self.ui.pushButton_O.clicked.connect(self.append.addO)		self.ui.pushButton_P.clicked.connect(self.append.addP)		self.ui.pushButton_Q.clicked.connect(self.append.addQ)		self.ui.pushButton_R.clicked.connect(self.append.addR)		self.ui.pushButton_S.clicked.connect(self.append.addS)		self.ui.pushButton_T.clicked.connect(self.append.addT)		self.ui.pushButton_U.clicked.connect(self.append.addU)		self.ui.pushButton_V.clicked.connect(self.append.addV)		self.ui.pushButton_W.clicked.connect(self.append.addW)		self.ui.pushButton_X.clicked.connect(self.append.addX)		self.ui.pushButton_Y.clicked.connect(self.append.addY)		self.ui.pushButton_Z.clicked.connect(self.append.addZ)		self.ui.pushButton_Comma.clicked.connect(self.append.addComma)		self.ui.pushButton_Enter.clicked.connect(self.append.addEnter)		self.ui.pushButton_Exclamation.clicked.connect(self.append.addExclamation)		self.ui.pushButton_QuestionMark.clicked.connect(self.append.addQuestionmark)		self.ui.pushButton_Backspace1.clicked.connect(self.append.backspace)		self.ui.pushButton_Backspace2.clicked.connect(self.append.backspace)		self.ui.pushButton_Period1.clicked.connect(self.append.addPeriod)		self.ui.pushButton_Period2.clicked.connect(self.append.addPeriod)		self.ui.pushButton_Period3.clicked.connect(self.append.addPeriod)		self.ui.pushButton_Space1.clicked.connect(self.append.addSpace)		self.ui.pushButton_Space2.clicked.connect(self.append.addSpace)		self.ui.pushButton_Space3.clicked.connect(self.append.addSpace)	def typewriterSlot(self, type, number):		print "got to typewriter slot:", type, number		if(type == Keyboard.TYPE_SELECT):			form_typewriter.focusWidget().click()		elif(type == Keyboard.TYPE_FORWARD):			form_typewriter.focusNextChild()		else:			form_typewriter.focusPreviousChild()class Append():	def __init__(self, ui):		self.ui = ui	def add(self, letter):		output = self.ui.plainTextEdit.toPlainText()		self.ui.plainTextEdit.setPlainText(output + letter)	def addA(self):		self.add("A")	def addB(self):		self.add("B")	def addC(self):		self.add("C")	def addD(self):		self.add("D")	def addE(self):		self.add("E")	def addF(self):		self.add("F")	def addG(self):		self.add("G")	def addH(self):		self.add("H")	def addI(self):		self.add("I")	def addJ(self):		self.add("J")	def addK(self):		self.add("K")	def addL(self):		self.add("L")	def addM(self):		self.add("M")	def addN(self):		self.add("N")	def addO(self):		self.add("O")	def addP(self):		self.add("P")	def addQ(self):		self.add("Q")	def addR(self):		self.add("R")	def addS(self):		self.add("S")	def addT(self):		self.add("T")	def addU(self):		self.add("U")	def addV(self):		self.add("V")	def addW(self):		self.add("W")	def addX(self):		self.add("X")	def addY(self):		self.add("Y")	def addZ(self):		self.add("Z")	def addComma(self) :		self.add(",")	def addPeriod(self):		self.add(".")		self.speak()	def addExclamation(self):		self.add("!")		self.speak()	def addQuestionmark(self):		self.add("?")		self.speak()				def addSpace(self):		self.add(" ")			def addEnter(self):		self.add("\n")		self.speak()	def backspace(self):		output = self.ui.plainTextEdit.toPlainText()		self.ui.plainTextEdit.setPlainText(output[0:-1])	def speak(self):		output = self.ui.plainTextEdit.toPlainText()		espeak.synth(output.toAscii().data()) 			class onFocusManager(QObject):	def __init__(self):		QObject.__init__(self)		self.sA = pygame.mixer.Sound(AUDIO_PATH+"/A.wav")		self.sB = pygame.mixer.Sound(AUDIO_PATH+"/B.wav")		self.sC = pygame.mixer.Sound(AUDIO_PATH+"/C.wav")		self.sD = pygame.mixer.Sound(AUDIO_PATH+"/D.wav")		self.sE = pygame.mixer.Sound(AUDIO_PATH+"/E.wav")		self.sF = pygame.mixer.Sound(AUDIO_PATH+"/F.wav")		self.sG = pygame.mixer.Sound(AUDIO_PATH+"/G.wav")		self.sH = pygame.mixer.Sound(AUDIO_PATH+"/H.wav")		self.sI = pygame.mixer.Sound(AUDIO_PATH+"/I.wav")		self.sJ = pygame.mixer.Sound(AUDIO_PATH+"/J.wav")		self.sK = pygame.mixer.Sound(AUDIO_PATH+"/K.wav")		self.sL = pygame.mixer.Sound(AUDIO_PATH+"/L.wav")		self.sM = pygame.mixer.Sound(AUDIO_PATH+"/M.wav")		self.sN = pygame.mixer.Sound(AUDIO_PATH+"/N.wav")		self.sO = pygame.mixer.Sound(AUDIO_PATH+"/O.wav")		self.sP = pygame.mixer.Sound(AUDIO_PATH+"/P.wav")		self.sQ = pygame.mixer.Sound(AUDIO_PATH+"/Q.wav")		self.sR = pygame.mixer.Sound(AUDIO_PATH+"/R.wav")		self.sS = pygame.mixer.Sound(AUDIO_PATH+"/S.wav")		self.sT = pygame.mixer.Sound(AUDIO_PATH+"/T.wav")		self.sU = pygame.mixer.Sound(AUDIO_PATH+"/U.wav")		self.sV = pygame.mixer.Sound(AUDIO_PATH+"/V.wav")		self.sW = pygame.mixer.Sound(AUDIO_PATH+"/W.wav")		self.sX = pygame.mixer.Sound(AUDIO_PATH+"/X.wav")		self.sY = pygame.mixer.Sound(AUDIO_PATH+"/Y.wav")		self.sZ = pygame.mixer.Sound(AUDIO_PATH+"/Z.wav")		self.sComma = pygame.mixer.Sound(AUDIO_PATH+"/comma.wav")		self.sClear = pygame.mixer.Sound(AUDIO_PATH+"/clear.wav")		self.sEnter = pygame.mixer.Sound(AUDIO_PATH+"/enter.wav")		self.sExclamation = pygame.mixer.Sound(AUDIO_PATH+"/exclamation.wav")		self.sPeriod = pygame.mixer.Sound(AUDIO_PATH+"/period.wav")		self.sSpace = pygame.mixer.Sound(AUDIO_PATH+"/space.wav")		self.sQuestion = pygame.mixer.Sound(AUDIO_PATH+"/question.wav")		self.sBackspace = pygame.mixer.Sound(AUDIO_PATH+"/backspace.wav")	def eventFilter(self, obj, event):		if(event.type() == QEvent.FocusIn):			if(obj.objectName() == "pushButton_A"):				self.sA.play()			elif(obj.objectName() == "pushButton_B"):				self.sB.play()				elif(obj.objectName() == "pushButton_C"):				self.sC.play()				elif(obj.objectName() == "pushButton_D"):				self.sD.play()				elif(obj.objectName() == "pushButton_E"):				self.sE.play()				elif(obj.objectName() == "pushButton_F"):				self.sF.play()				elif(obj.objectName() == "pushButton_G"):				self.sG.play()				elif(obj.objectName() == "pushButton_H"):				self.sH.play()				elif(obj.objectName() == "pushButton_I"):				self.sI.play()				elif(obj.objectName() == "pushButton_J"):				self.sJ.play()				elif(obj.objectName() == "pushButton_K"):				self.sK.play()				elif(obj.objectName() == "pushButton_L"):				self.sL.play()				elif(obj.objectName() == "pushButton_M"):				self.sM.play()				elif(obj.objectName() == "pushButton_N"):				self.sN.play()				elif(obj.objectName() == "pushButton_O"):				self.sO.play()				elif(obj.objectName() == "pushButton_P"):				self.sP.play()				elif(obj.objectName() == "pushButton_Q"):				self.sQ.play()				elif(obj.objectName() == "pushButton_R"):				self.sR.play()				elif(obj.objectName() == "pushButton_S"):				self.sS.play()				elif(obj.objectName() == "pushButton_T"):				self.sT.play()				elif(obj.objectName() == "pushButton_U"):				self.sU.play()				elif(obj.objectName() == "pushButton_V"):				self.sV.play()				elif(obj.objectName() == "pushButton_W"):				self.sW.play()				elif(obj.objectName() == "pushButton_X"):				self.sX.play()				elif(obj.objectName() == "pushButton_Y"):				self.sY.play()				elif(obj.objectName() == "pushButton_Z"):				self.sZ.play()				elif(obj.objectName() == "pushButton_Comma"):				self.sComma.play()			elif(obj.objectName() == "pushButton_Clear"):				self.sClear.play()			elif(obj.objectName() == "pushButton_Enter"):				self.sEnter.play()			elif(obj.objectName() == "pushButton_Exclamation"):				self.sExclamation.play()			elif(obj.objectName() == "pushButton_Period1" or \				 obj.objectName() == "pushButton_Period2" or \				 obj.objectName() == "pushButton_Period3"):				self.sPeriod.play()			elif(obj.objectName() == "pushButton_Space1" or \				 obj.objectName() == "pushButton_Space2" or \				 obj.objectName() == "pushButton_Space3"):				self.sSpace.play()			elif(obj.objectName() == "pushButton_QuestionMark"):				self.sQuestion.play()			elif(obj.objectName() == "pushButton_Backspace1" or \				 obj.objectName() == "pushButton_Backspace2") :				self.sBackspace.play()		return False	if __name__ == '__main__':	app = QtGui.QApplication([])	pygame.mixer.init()	form_typewriter = QtGui.QWidget()	form_typewriter.setWindowTitle("KinetACI - Typewriter")	ui = typewriter.Ui_form_typewriter()	ui.setupUi(form_typewriter)	focusIn = onFocusManager()	ui.pushButton_A.installEventFilter(focusIn)	ui.pushButton_B.installEventFilter(focusIn)	ui.pushButton_C.installEventFilter(focusIn)	ui.pushButton_D.installEventFilter(focusIn)	ui.pushButton_E.installEventFilter(focusIn)	ui.pushButton_F.installEventFilter(focusIn)	ui.pushButton_G.installEventFilter(focusIn)	ui.pushButton_H.installEventFilter(focusIn)	ui.pushButton_I.installEventFilter(focusIn)	ui.pushButton_J.installEventFilter(focusIn)	ui.pushButton_K.installEventFilter(focusIn)	ui.pushButton_L.installEventFilter(focusIn)	ui.pushButton_M.installEventFilter(focusIn)	ui.pushButton_N.installEventFilter(focusIn)	ui.pushButton_O.installEventFilter(focusIn)	ui.pushButton_P.installEventFilter(focusIn)	ui.pushButton_Q.installEventFilter(focusIn)	ui.pushButton_R.installEventFilter(focusIn)	ui.pushButton_S.installEventFilter(focusIn)	ui.pushButton_T.installEventFilter(focusIn)	ui.pushButton_U.installEventFilter(focusIn)	ui.pushButton_V.installEventFilter(focusIn)	ui.pushButton_W.installEventFilter(focusIn)	ui.pushButton_X.installEventFilter(focusIn)	ui.pushButton_Y.installEventFilter(focusIn)	ui.pushButton_Z.installEventFilter(focusIn)	ui.pushButton_Comma.installEventFilter(focusIn)	ui.pushButton_Clear.installEventFilter(focusIn)	ui.pushButton_Enter.installEventFilter(focusIn)	ui.pushButton_Exclamation.installEventFilter(focusIn)	ui.pushButton_Period1.installEventFilter(focusIn)	ui.pushButton_Period2.installEventFilter(focusIn)	ui.pushButton_Period3.installEventFilter(focusIn)	ui.pushButton_Space1.installEventFilter(focusIn)	ui.pushButton_Space2.installEventFilter(focusIn)	ui.pushButton_Space3.installEventFilter(focusIn)	ui.pushButton_QuestionMark.installEventFilter(focusIn)	ui.pushButton_Backspace1.installEventFilter(focusIn)	ui.pushButton_Backspace2.installEventFilter(focusIn)	connector = Connector(ui, form_typewriter)	win = Viewer(connector)	connector.connect()	win.setWindowTitle("KinectACI - Kinect Data")	form_typewriter.show()	win.show()	app.exec_()